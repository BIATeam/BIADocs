# === CONFIG ===
$RootPath = "C:\sources\Project\Angular"
$DryRun   = $false   # true = report; false = actually modify files

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# === REGEXS (literal '...') ===
$reComponent   = [regex]'@Component\s*\(\s*\{[\s\S]*?\}\s*\)'
$reImports     = [regex]'imports\s*:\s*\[(?<arr>[\s\S]*?)\]'
$reTemplateUrl = [regex]'templateUrl\s*:\s*(["''])(?<url>[\s\S]*?)(?<!\\)\1'

# --- utils ---
function Resolve-TemplatePath {
  param([string]$ComponentFile, [string]$TemplateUrl)
  if (-not $TemplateUrl) { return $null }
  $tpl  = $TemplateUrl.Trim("'",'"').Replace('/', [IO.Path]::DirectorySeparatorChar)
  $base = Split-Path -Path $ComponentFile -Parent
  $p    = Join-Path -Path $base -ChildPath $tpl
  try   { return (Resolve-Path -LiteralPath $p -ErrorAction Stop).Path }
  catch { if (Test-Path -LiteralPath $tpl) { return (Resolve-Path $tpl).Path } ; return $null }
}

function Get-DirectiveUsageCounts {
  param([string]$TemplateContent, [string[]]$Directives)
  $opt = [System.Text.RegularExpressions.RegexOptions]::IgnoreCase

  $counts = @{}

  if ($Directives -contains 'NgIf') {
    $counts.NgIf = [regex]::Matches($TemplateContent, '\*ngIf(?=\s*=)', $opt).Count
  }
  if ($Directives -contains 'NgFor') {
    $counts.NgFor = [regex]::Matches($TemplateContent, '\*ngFor(?=\s*=)', $opt).Count
  }
  if ($Directives -contains 'NgSwitch') {
    $counts.NgSwitch =
      [regex]::Matches($TemplateContent, '\[ngSwitch\](?=\s*=)', $opt).Count +
      [regex]::Matches($TemplateContent, '\*ngSwitchCase(?=\s*=)', $opt).Count +
      [regex]::Matches($TemplateContent, '\*ngSwitchDefault(?=\s*=)', $opt).Count
  }

  return $counts
}

function Prune-ImportsArray {
  param([string]$arr, [string[]]$drop) 
  if (-not $arr) { return $arr }
  $keep = New-Object System.Collections.Generic.List[string]
  foreach ($raw in ($arr -split ',')) {
    $t = ($raw -replace '//.*$','').Trim()
    if (-not $t) { continue }
    $m = [regex]::Match($t, '^[A-Za-z_]\w*')
    if ($m.Success -and ($drop -contains $m.Value)) { continue }
    $keep.Add($t)
  }
  if ($keep.Count -eq 0) { return '' }
  return ($keep -join ",`n    ")
}

# === MAIN ===
$files = Get-ChildItem -Path $RootPath -Recurse -Filter *.component.ts -File
if (-not $files) { Write-Host "No .component.ts files found."; exit 0 }

$modified=0; $skNoTpl=0; $skTplNF=0; $skNoImports=0

foreach ($f in $files) {
  $text = Get-Content -LiteralPath $f.FullName -Raw
  $comps = @($reComponent.Matches($text))
  if ($comps.Count -eq 0) { continue }

  $comps = $comps | Sort-Object Index -Descending
  $fileChanged = $false

  foreach ($m in $comps) {
    $block = $m.Value

    $mImp = $reImports.Match($block)
    if (-not $mImp.Success) { $skNoImports++; continue }
    $importsRaw = $mImp.Groups['arr'].Value

    $present = @()
    foreach ($n in @('NgIf','NgFor','NgSwitch')) {
      if ([regex]::IsMatch($importsRaw, '(?<![\w$])' + [regex]::Escape($n) + '(?![\w$])')) { $present += $n }
    }
    if ($present.Count -eq 0) { continue }

    $mTpl = $reTemplateUrl.Match($block)
    if (-not $mTpl.Success) { $skNoTpl++; continue }
    $tplPath = Resolve-TemplatePath -ComponentFile $f.FullName -TemplateUrl $mTpl.Groups['url'].Value
    if (-not $tplPath) { Write-Warning "Template not found: $($f.FullName) -> $($mTpl.Groups['url'].Value)"; $skTplNF++; continue }
    $tpl = Get-Content -LiteralPath $tplPath -Raw

    $counts = Get-DirectiveUsageCounts -TemplateContent $tpl -Directives $present

    $logParts = @()
    foreach ($n in $present) { $logParts += "$n=$($counts[$n])" }
    Write-Host ("[INFO] {0} -> {1} | template: {2}" -f $f.FullName, ($logParts -join ', '), $tplPath) -ForegroundColor DarkGray

    $unused = @($present | Where-Object { ($counts.ContainsKey($_) -and $counts[$_] -eq 0) })
    if ($unused.Count -eq 0) 
    { 
      Write-Host ("[IGNORED] {0}" -f $f.FullName) -ForegroundColor DarkYellow
      continue 
    }

    $newArr   = Prune-ImportsArray -arr $importsRaw -drop $unused
    $newBlock = $reImports.Replace($block, { param($mm) "imports: [`n    $newArr`n]" })

    $text = $text.Remove($m.Index, $m.Length).Insert($m.Index, $newBlock)
    $fileChanged = $true

    Write-Host ("[CLEANED] {0} -> {1}" -f $f.FullName, ($unused -join ', ')) -ForegroundColor Green
  }

  if ($fileChanged) {
    $modified++
    if (-not $DryRun) { Set-Content -LiteralPath $f.FullName -Value $text -NoNewline }
  }
}

"`nModified components        : $modified"
"Skipped (no templateUrl)     : $skNoTpl"
"Skipped (template not found) : $skTplNF"
"Skipped (no imports[])       : $skNoImports`n"

if (-not $DryRun) { Write-Host "Running: npm run clean ..."; Set-Location $RootPath; npm run clean }
Pause